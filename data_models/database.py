import configparser
import os
from enum import Enum
from typing import List
import oracledb
import logging
from backend.process_maneger import linking_words
# Configure logging for database module
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

class ProgressStack(Enum):
    DB_CONFIG_LOADED = 0
    DB_CONNECTION_ESTABLISHED = 1

class RootDataStack:
    constant_tags_list: List[str] = ["code", "poetry", "medical", "legal"]
    progress_stack: List[str] = []


class OrcaleDatabase:

    def __init__(self):
        config = configparser.ConfigParser()
        project_root = os.path.dirname(os.path.dirname(__file__))
        config_path = os.path.join(project_root, "config.ini")
        config.read(config_path)

        self.host = config.get("DATABASE", "HOST")
        self.port = config.getint("DATABASE", "PORT")
        self.service_name = config.get("DATABASE", "SERVICE_NAME")
        self.user = config.get("DATABASE", "USER")
        self.password = config.get("DATABASE", "PASSWORD")
        self.tags_list: List[str] = []
        self._connect_error = None


        try:
            self.connection = oracledb.connect(
                user=self.user,
                password=self.password,
                dsn=f"{self.host}:{self.port}/{self.service_name}",
            )
            logger.info("Database connection established")
        except Exception as e:
            # Keep the error message for callers to inspect and continue without a connection.
            logger.error(f"Connection attempt failed: {str(e)}")
            self.connection = None
            self._connect_error = str(e)


    def get_connection(self):
        if self.connection is None:
            raise RuntimeError("Database connection is not available. Is the Oracle client installed and configured?")
        return self.connection

    def close_connection(self):
        if self.connection:
            self.connection.close()

    def get_all_tables_names(self)->list:
        with self.connection.cursor() as cur:
            sql_template_1 = "SELECT table_name FROM user_tables ORDER BY table_name"
            sql_template_2 = "SELECT table_name FROM user_tables"
            cur.execute(sql_template_1)
            tables = [row[0] for row in cur.fetchall()]
        return tables

    def is_table_exists(self, table_name):
        tables = self.get_all_tables_names()
        print(tables)
        return table_name.upper() in tables


    def execute_query(self,sql:str):
        # sql = f"CREATE TABLE tags (id NUMBER PRIMARY KEY, name VARCHAR2(100))"
        with self.connection.cursor() as cur:
            cur.execute(sql)
            self.connection.commit()


    def preload_base_models(self):

        try:
            self.__create_initial_tables()
        except Exception as e:
            logging.debug(f"Warning: preload base models - failure: creating initial tables: {e}")
            print(f"Warning: preload base models - failure: creating initial tables: {e}")
        try:
            self.__load_tags_models()
        except Exception as e:
            print(f"Warning: preload base models - failure: loading tags models: {e}")
        try:
            self.__insert_root_tokens_models()
        except Exception as e:
            print(f"Warning: preload base models - failure: inserting root tokens models: {e}")



    def __create_initial_tables(self):
        create_tags_table_sql = """
        CREATE TABLE tags (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR2(100) NOT NULL,
            reference VARCHAR2(100),
            usage_count NUMBER DEFAULT 0
        )
        """

        if not self.is_table_exists("tags"):
            print("Creating tags table...")
            self.execute_query(create_tags_table_sql)

        create_linked_words_table_sql = """
        CREATE TABLE linked_words (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            word VARCHAR2(100) NOT NULL"""

        if not self.is_table_exists("linked_words"):
            print("Creating linked_words table...")
            self.execute_query(create_linked_words_table_sql)

        create_metadata_table_sql = """
        CREATE TABLE metadata(
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            author VARCHAR2(200),
            title VARCHAR2(300),
            pages_count NUMBER,
            word_count NUMBER,
            lines_count NUMBER,
            avarage_line_length NUMBER,
            created_at DATE,
            updated_at DATE
        )
        """
        if not self.is_table_exists("metadata"):
            print("Creating metadata table...")
            self.execute_query(create_metadata_table_sql)

        create_text_table_sql = """
        CREATE TABLE text(
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            path VARCHAR(400) NOT NULL,
            tag_id NUMBER,
            metadata_id NUMBER,
            FOREIGN KEY (metadata_id) REFERENCES metadata(id),
            FOREIGN KEY (tag_id) REFERENCES tags(id)
        )
        """
        if not self.is_table_exists("text"):
            print("Creating text table...")
            self.execute_query(create_text_table_sql)


        create_tokens_table_sql = """
        CREATE TABLE tokens(
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            text_id NUMBER,
            token VARCHAR2(100),
            page NUMBER,
            line NUMBER,
            position NUMBER,
            prev_token_id NUMBER,
            next_token_id NUMBER,
            tag_id NUMBER,
            FOREIGN KEY (text_id) REFERENCES text(id)
        )
        """
        if not self.is_table_exists("tokens"):
            print("Creating tokens table...")
            self.execute_query(create_tokens_table_sql)


    def __load_tags_models(self):

        sql_bricks = ["code", "poetry", "medical", "legal"]

        for key in sql_bricks:
            if self.connection:
                with self.connection.cursor() as cur:
                    cur.execute(f"SELECT COUNT(*) FROM TAGS WHERE name = '{key}'")
                    print(f"Checking existence of tag '{key}'...")
                    row = cur.fetchone()
                    if row and row[0] > 0:
                        print(row)
                        print(f"Tag '{key}' already exists. Skipping insertion.")
                    else:
                        self.execute_query(f"INSERT INTO TAGS (name, reference, usage_count) VALUES ('{key}', 'base_model', 0)")


    def __insert_root_tokens_models(self):
        # If not connected, skip root model import.
        if not self.connection:
            return
        print("-" * 50)
        print("insert root tokens models...")
        # find root folder and check which tags exist
        root_model_files = []
        input_tags_list = []
        root_models_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data_models", "root_models")
        print(f"root models dir path: {root_models_dir}")

        if os.path.isdir(root_models_dir):
            print("root models dir exists")
            print("root model data sources:")
            for root, dirs, files in os.walk(root_models_dir):
                # collect file names (not full paths) so we can extract tag prefix
                root_model_files.extend(files)
                for file_path in root_model_files:
                    print(f"\t{file_path}")


            input_tags_list = { (f.split('_', 1)[0].strip()) for f in root_model_files if f and '_' in f }
            print("tags from sources:")
            for tag in input_tags_list:
                print(f"\t{tag}")

            # For any filenames without an underscore, use the filename without extension
            input_tags_list.update({ os.path.splitext(f)[0].strip() for f in root_model_files if f and '_' not in f })

            for tag_name in input_tags_list:
                if not tag_name:
                    continue
                tag_name_norm = tag_name.strip()

                # Check existence in the tags table and insert if missing
                try:
                    with self.connection.cursor() as cur:
                        cur.execute("SELECT id FROM tags WHERE name = :name", [tag_name_norm])
                        existing = cur.fetchone()
                        # if not exist insert default tokens for each tag
                        if not existing:
                            cur.execute(
                                "INSERT INTO tags (name, reference, usage_count) VALUES (:name, :ref, :cnt)",
                                [tag_name_norm, 'root_model', 0]
                            )
                            # commit after insert
                            self.connection.commit()
                except Exception as e:
                    # If the tags table doesn't exist or other DB error occurs, skip and continue
                    continue



        # if exist open the file of root tokens and insert them into the tokens table with relevant tag
        for file_name in root_model_files:
            file_path = os.path.join(root_models_dir, file_name)
            if not os.path.isfile(file_path):
                continue

            # Derive tag name from filename
            if '_' in file_name:
                tag_name = file_name.split('_', 1)[0].strip()
            else:
                tag_name = os.path.splitext(file_name)[0].strip()

            # Get tag ID
            with self.connection.cursor() as cur:
                cur.execute("SELECT id FROM tags WHERE name = :name", [tag_name])
                tag_row = cur.fetchone()
                if not tag_row:
                    continue  # Tag not found, skip this file
                tag_id = tag_row[0]

            # Read tokens from file and insert into tokens table
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, start=1):
                    token = line.strip()
                    if not token:
                        continue  # Skip empty lines

                    with self.connection.cursor() as cur:
                        cur.execute(
                            "INSERT INTO tokens (text_id, token, page, line, position, tag_id) "
                            "VALUES (:text_id, :token, :page, :line, :position, :tag_id)",
                            [None, token, None, line_num, None, tag_id]
                        )
                        # Update the tags.usage_count for the tag this token belongs to.
                        try:
                            cur.execute(
                                "UPDATE tags SET usage_count = NVL(usage_count, 0) + 1 WHERE id = :id",
                                [tag_id]
                            )
                        except Exception as e:
                            print(f"Warning: failed to update usage_count for tag_id {tag_id}: {e}")
                            pass
                self.connection.commit()

    def load_tags_list(self):
        # If not connected, leave tags_list empty and return silently.
        if not self.connection:
            self.tags_list = []
            return

        with self.connection.cursor() as cur:
            cur.execute("SELECT name FROM tags")
            rows = cur.fetchall()
            self.tags_list = [row[0] for row in rows]

    def get_tags_list(self)->List[str]:
        if not self.tags_list:
            self.load_tags_list()
            print(f"Tags loaded from database: {self.tags_list}")
        if not self.tags_list:
            print("No tags loaded from database Alternative : using constant tags list")
            self.tags_list = RootDataStack.constant_tags_list
        return self.tags_list

    def insert_into_text_table(self, path:str, tag_id:int, metadata_id:int):
        try:
            with self.connection.cursor() as cur:
                cur.execute(
                    "INSERT INTO text (path, tag_id, metadata_id) VALUES (:path, :tag_id, :metadata_id)",
                    [path, tag_id, metadata_id]
                )
                self.connection.commit()
        except Exception as e:
            print(f"Error inserting into text table: {e}")


    def generate_tokens_root_vector(self) -> List[str]:
        vector = []
        with self.connection.cursor() as cur:
            cur.execute('SELECT token, name FROM tokens JOIN tags ON tokens.tag_id = tags.id')
            vector = cur.fetchall()
        print(f"Generated root tokens vector with {len(vector)} entries")
        return vector

    def get_tag_id_by_name(self, tag_name: str):
        with self.connection.cursor() as cur:
            cur.execute("SELECT id FROM tags WHERE name = :name", [tag_name])
            row = cur.fetchone()
            if row:
                return row[0]
        return None

    def add_tags_new_row(self, tag_name: str, reference: str = 'derived_model'):
        try:
            with self.connection.cursor() as cur:
                cur.execute(
                    "INSERT INTO tags (name, reference, usage_count) VALUES (:name, :ref, 0)",
                    [tag_name, reference]
                )
                self.connection.commit()
        except Exception as e:
            print(f"Error inserting new tag '{tag_name}': {e}")

    def insert_into_tokens_table(self, token_table_dump: List[List]):
        try:
            with self.connection.cursor() as cur:
                for token_data in token_table_dump:
                    cur.execute(
                        "INSERT INTO tokens (text_id, token, page, line, position, tag_id) "
                        "VALUES (:text_id, :token, :page, :line, :position, :tag_id)",
                        token_data
                    )
                self.connection.commit()
        except Exception as e:
            print(f"Error inserting into tokens table: {e}")



    def find_text_id_by_name(self, path:str):
        with self.connection.cursor() as cur:
            cur.execute("SELECT id FROM text WHERE path = :path", [path])
            row = cur.fetchone()
            if row:
                return row[0]
        return None